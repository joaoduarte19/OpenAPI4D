// ***************************************************************************
//
// OpenAPI Generator for Delphi
//
// Copyright (c) 2021 João Antônio Duarte
//
// https://github.com/joaoduarte19/OpenApi4D
//
// ***************************************************************************
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// ***************************************************************************

unit OpenAPI.Security;

interface

uses
  System.Generics.Collections,
  OpenAPI.Types;

type
  TOpenAPISecurityRequirement = class(TOpenAPIObjectMap < TList < string >> );

  TOpenAPISecurityRequirementList = class(TOpenAPISecurityRequirement);

  TOpenAPISecurity = class
  private
    FDescription: Nullable<string>;
  protected
    function GetType: string; virtual; abstract;
  public
    /// <summary>
    /// REQUIRED. The type of the security scheme.
    /// </summary>
    [OpenAPIField('type')]
    property &Type: string read GetType;
    /// <summary>
    /// A description for security scheme. CommonMark syntax MAY be used for rich text representation.
    /// </summary>
    [OpenAPIField('description')]
    property Description: Nullable<string> read FDescription write FDescription;
  end;

  TOpenAPISecurityList = class(TObjectList<TOpenAPISecurity>);

  TOpenAPISecurityMap = class(TOpenAPIObjectMap<TOpenAPISecurity>);

  TOpenAPISecurityApiKey = class(TOpenAPISecurity)
  public type
    TLocation = (Query, Header, Cookie);
  private
    FName: string;
    FIn: TLocation;
  protected
    function GetType: string; override;
  public
    /// <summary>
    /// REQUIRED. The name of the header, query or cookie parameter to be used.
    /// </summary>
    [OpenAPIField('name')]
    property Name: string read FName write FName;
    /// <summary>
    /// REQUIRED. The location of the API key.
    /// </summary>
    [OpenAPIField('in')]
    property &In: TLocation read FIn write FIn;
  end;

  TOpenAPISecurityHttp = class(TOpenAPISecurity)
  private
    FScheme: string;
    FBearerFormat: Nullable<string>;
  protected
    function GetType: string; override;
  public
    /// <summary>
    /// REQUIRED. The name of the HTTP Authorization scheme to be used in the Authorization header as defined in RFC7235.
    /// The values used SHOULD be registered in the IANA Authentication Scheme registry.
    /// </summary>
    [OpenAPIField('scheme')]
    property Scheme: string read FScheme write FScheme;
    /// <summary>
    /// A hint to the client to identify how the bearer token is formatted.
    // Bearer tokens are usually generated by an authorization server, so this information is primarily for documentation purposes.
    /// </summary>
    [OpenAPIField('bearerFormat')]
    property BearerFormat: Nullable<string> read FBearerFormat write FBearerFormat;
  end;

  TOpenAPISecurityMutualTLS = class(TOpenAPISecurity)
  protected
    function GetType: string; override;
  end;

  TOauthFlows = class;

  TOpenAPISecurityOauth2 = class(TOpenAPISecurity)
  private
    FFlows: TOauthFlows;
  protected
    function GetType: string; override;
  public
    constructor Create;
    destructor Destroy; override;
    /// <summary>
    /// REQUIRED. An object containing configuration information for the flow types supported.
    /// </summary>
    [OpenAPIField('flows')]
    property Flows: TOauthFlows read FFlows;
  end;

  TOpenAPISecurityOpenIdConnect = class(TOpenAPISecurity)
  private
    FOpenIdConnectUrl: string;
  protected
    function GetType: string; override;
  public
    /// <summary>
    /// REQUIRED. OpenId Connect URL to discover OAuth2 configuration values. This MUST be in the form of a URL.
    /// The OpenID Connect standard requires the use of TLS.
    /// </summary>
    [OpenAPIField('openIdConnectUrl')]
    property OpenIdConnectUrl: string read FOpenIdConnectUrl write FOpenIdConnectUrl;
  end;

  TOauthFlow = class;

  TOauthFlows = class
  private
    [OpenAPIField('implicit')]
    FImplicit: TOauthFlow;

    [OpenAPIField('password')]
    FPassword: TOauthFlow;

    [OpenAPIField('clientCredentials')]
    FClientCredentials: TOauthFlow;

    [OpenAPIField('authorizationCode')]
    FAuthorizationCode: TOauthFlow;

    function GetAuthorizationCode: TOauthFlow;
    function GetClientCredentials: TOauthFlow;
    function GetImplicit: TOauthFlow;
    function GetPassword: TOauthFlow;
  public
    constructor Create;
    destructor Destroy; override;
    /// <summary>
    /// Configuration for the OAuth Implicit flow
    /// </summary>
    property Implicit: TOauthFlow read GetImplicit;
    /// <summary>
    /// Configuration for the OAuth Resource Owner Password flow
    /// </summary>
    property Password: TOauthFlow read GetPassword;
    /// <summary>
    /// Configuration for the OAuth Client Credentials flow. Previously called application in OpenAPI 2.0.
    /// </summary>
    property ClientCredentials: TOauthFlow read GetClientCredentials;
    /// <summary>
    /// Configuration for the OAuth Authorization Code flow. Previously called accessCode in OpenAPI 2.0.
    /// </summary>
    property AuthorizationCode: TOauthFlow read GetAuthorizationCode;
  end;

  TStringMap = class(TDictionary<string, string>);

  TOauthFlow = class
  private
    [OpenAPIField('authorizationUrl')]
    FAuthorizationUrl: string;

    [OpenAPIField('tokenUrl')]
    FTokenUrl: string;

    [OpenAPIField('refreshUrl')]
    FRefreshUrl: Nullable<string>;

    [OpenAPIField('scopes')]
    FScopes: TStringMap;
  public
    constructor Create;
    destructor Destroy; override;
    /// <summary>
    /// REQUIRED. The authorization URL to be used for this flow. This MUST be in the form of a URL. The OAuth2 standard requires the use of TLS.
    /// </summary>
    property AuthorizationUrl: string read FAuthorizationUrl write FAuthorizationUrl;
    /// <summary>
    /// REQUIRED. The token URL to be used for this flow. This MUST be in the form of a URL. The OAuth2 standard requires the use of TLS.
    /// </summary>
    property TokenUrl: string read FTokenUrl write FTokenUrl;
    /// <summary>
    /// The URL to be used for obtaining refresh tokens. This MUST be in the form of a URL. The OAuth2 standard requires the use of TLS.
    /// </summary>
    property RefreshUrl: Nullable<string> read FRefreshUrl write FRefreshUrl;
    /// <summary>
    /// REQUIRED. The available scopes for the OAuth2 security scheme. A map between the scope name and a short description for it.
    /// The map MAY be empty.
    /// </summary>
    property Scopes: TStringMap read FScopes;
  end;

implementation

uses
  System.SysUtils;

{ TOpenAPISecurityApiKey }

function TOpenAPISecurityApiKey.GetType: string;
begin
  Result := 'apiKey';
end;

{ TOpenAPISecurityHttp }

function TOpenAPISecurityHttp.GetType: string;
begin
  Result := 'http';
end;

{ TOpenAPISecurityMutualTLS }

function TOpenAPISecurityMutualTLS.GetType: string;
begin
  Result := 'mutualTLS';
end;

{ TOpenAPISecurityOauth2 }

constructor TOpenAPISecurityOauth2.Create;
begin
  inherited Create;
  FFlows := TOauthFlows.Create;
end;

destructor TOpenAPISecurityOauth2.Destroy;
begin
  FreeAndNil(FFlows);
  inherited Destroy;
end;

function TOpenAPISecurityOauth2.GetType: string;
begin
  Result := 'oauth2';
end;

{ TOpenAPISecurityOpenIdConnect }

function TOpenAPISecurityOpenIdConnect.GetType: string;
begin
  Result := 'openIdConnect';
end;

{ TOauthFlows }

constructor TOauthFlows.Create;
begin
  inherited Create;
  FImplicit := nil;
  FAuthorizationCode := nil;
  FClientCredentials := nil;
  FPassword := nil;
end;

destructor TOauthFlows.Destroy;
begin
  if Assigned(FImplicit) then
    FreeAndNil(FImplicit);
  if Assigned(FAuthorizationCode) then
    FreeAndNil(FAuthorizationCode);
  if Assigned(FClientCredentials) then
    FreeAndNil(FClientCredentials);
  if Assigned(FPassword) then
    FreeAndNil(FPassword);
  inherited;
end;

function TOauthFlows.GetAuthorizationCode: TOauthFlow;
begin
  if not Assigned(FAuthorizationCode) then
    FAuthorizationCode := TOauthFlow.Create;
  Result := FAuthorizationCode;
end;

function TOauthFlows.GetClientCredentials: TOauthFlow;
begin
  if not Assigned(FClientCredentials) then
    FClientCredentials := TOauthFlow.Create;
  Result := FClientCredentials;
end;

function TOauthFlows.GetImplicit: TOauthFlow;
begin
  if not Assigned(FImplicit) then
    FImplicit := TOauthFlow.Create;
  Result := FImplicit;
end;

function TOauthFlows.GetPassword: TOauthFlow;
begin
  if not Assigned(FPassword) then
    FPassword := TOauthFlow.Create;
  Result := FPassword;
end;

{ TOauthFlow }

constructor TOauthFlow.Create;
begin
  inherited Create;
  FScopes := TStringMap.Create;
end;

destructor TOauthFlow.Destroy;
begin
  FreeAndNil(FScopes);
  inherited Destroy;
end;

end.
